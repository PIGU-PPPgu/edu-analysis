# ğŸ”„ æ•°æ®æ¢å¤ä»»åŠ¡é…ç½®
# ç”¨äºç¾éš¾æ¢å¤å’Œæ•°æ®è¿ç§»çš„æ¢å¤ä½œä¸š

apiVersion: v1
kind: ConfigMap
metadata:
  name: restore-scripts
  namespace: backup
  labels:
    app: backup-system
    component: restore
data:
  # æ•°æ®åº“æ¢å¤è„šæœ¬
  restore-database.sh: |
    #!/bin/bash
    set -euo pipefail
    
    # å‚æ•°éªŒè¯
    if [[ $# -lt 1 ]]; then
        echo "ç”¨æ³•: $0 <backup-name> [target-database]"
        echo "ç¤ºä¾‹: $0 supabase-backup-20241201-020000"
        exit 1
    fi
    
    BACKUP_NAME="$1"
    TARGET_DB="${2:-production}"
    RESTORE_DIR="/tmp/restore"
    
    log() {
        echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
    }
    
    # åˆ›å»ºæ¢å¤ç›®å½•
    mkdir -p "$RESTORE_DIR"
    cd "$RESTORE_DIR"
    
    log "å¼€å§‹æ•°æ®åº“æ¢å¤: $BACKUP_NAME"
    
    # ä»S3ä¸‹è½½å¤‡ä»½æ–‡ä»¶
    log "ä¸‹è½½å¤‡ä»½æ–‡ä»¶..."
    aws s3 cp "s3://${S3_BUCKET}/database/${BACKUP_NAME}.tar.gz" .
    
    # è§£å‹å¤‡ä»½æ–‡ä»¶
    log "è§£å‹å¤‡ä»½æ–‡ä»¶..."
    tar -xzf "${BACKUP_NAME}.tar.gz"
    
    # æ£€æŸ¥å¤‡ä»½æ–‡ä»¶
    if [[ ! -f "${BACKUP_NAME}-schema.sql" ]] || [[ ! -f "${BACKUP_NAME}-data.sql" ]]; then
        log "ERROR: å¤‡ä»½æ–‡ä»¶ä¸å®Œæ•´"
        exit 1
    fi
    
    # ç¡®è®¤æ¢å¤æ“ä½œ
    log "âš ï¸  å‡†å¤‡æ¢å¤æ•°æ®åº“: $TARGET_DB"
    log "âš ï¸  è¿™å°†è¦†ç›–ç°æœ‰æ•°æ®ï¼Œè¯·ç¡®è®¤æ“ä½œ!"
    
    if [[ "${FORCE_RESTORE:-false}" != "true" ]]; then
        log "è¯·è®¾ç½® FORCE_RESTORE=true ç¯å¢ƒå˜é‡ç¡®è®¤æ¢å¤æ“ä½œ"
        exit 1
    fi
    
    # åˆ›å»ºå¤‡ä»½æ—¶é—´æˆ³ï¼ˆæ¢å¤å‰å¤‡ä»½ï¼‰
    PRE_RESTORE_BACKUP="pre-restore-$(date +%Y%m%d-%H%M%S)"
    
    log "åˆ›å»ºæ¢å¤å‰å¤‡ä»½: $PRE_RESTORE_BACKUP"
    if command -v supabase &> /dev/null && [[ -n "${SUPABASE_DB_URL:-}" ]]; then
        supabase db dump > "$RESTORE_DIR/${PRE_RESTORE_BACKUP}.sql"
        aws s3 cp "${PRE_RESTORE_BACKUP}.sql" "s3://${S3_BUCKET}/pre-restore-backups/"
    fi
    
    # æ‰§è¡Œæ¢å¤
    log "å¼€å§‹æ¢å¤æ•°æ®åº“ç»“æ„..."
    if [[ -n "${SUPABASE_DB_URL:-}" ]]; then
        # ä½¿ç”¨pg_restoreæ¢å¤
        psql "$SUPABASE_DB_URL" < "${BACKUP_NAME}-schema.sql"
        
        log "å¼€å§‹æ¢å¤æ•°æ®..."
        psql "$SUPABASE_DB_URL" < "${BACKUP_NAME}-data.sql"
        
    elif command -v supabase &> /dev/null; then
        # ä½¿ç”¨Supabase CLIæ¢å¤
        supabase db reset --db-url "$SUPABASE_DB_URL"
        supabase db push --db-url "$SUPABASE_DB_URL" --schema "${BACKUP_NAME}-schema.sql"
        
        # æ¢å¤æ•°æ®éœ€è¦ç‰¹æ®Šå¤„ç†
        log "æ³¨æ„: æ•°æ®æ¢å¤éœ€è¦æ‰‹åŠ¨å¤„ç†"
        
    else
        log "ERROR: æ— æ³•æ‰¾åˆ°æ¢å¤å·¥å…·"
        exit 1
    fi
    
    # éªŒè¯æ¢å¤ç»“æœ
    log "éªŒè¯æ¢å¤ç»“æœ..."
    if [[ -n "${SUPABASE_DB_URL:-}" ]]; then
        TABLE_COUNT=$(psql "$SUPABASE_DB_URL" -t -c "SELECT count(*) FROM information_schema.tables WHERE table_schema='public';")
        log "æ¢å¤åè¡¨æ•°é‡: $TABLE_COUNT"
    fi
    
    # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    rm -rf "$RESTORE_DIR"
    
    log "æ•°æ®åº“æ¢å¤å®Œæˆ"

  # Kubernetesé…ç½®æ¢å¤è„šæœ¬
  restore-k8s-config.sh: |
    #!/bin/bash
    set -euo pipefail
    
    if [[ $# -lt 1 ]]; then
        echo "ç”¨æ³•: $0 <backup-name> [namespace]"
        echo "ç¤ºä¾‹: $0 k8s-config-backup-20241201-010000"
        exit 1
    fi
    
    BACKUP_NAME="$1"
    TARGET_NAMESPACE="${2:-}"
    RESTORE_DIR="/tmp/restore"
    
    log() {
        echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
    }
    
    mkdir -p "$RESTORE_DIR"
    cd "$RESTORE_DIR"
    
    log "å¼€å§‹Kubernetesé…ç½®æ¢å¤: $BACKUP_NAME"
    
    # ä¸‹è½½å¤‡ä»½æ–‡ä»¶
    log "ä¸‹è½½é…ç½®å¤‡ä»½..."
    aws s3 cp "s3://${S3_BUCKET}/kubernetes-config/${BACKUP_NAME}.tar.gz" .
    
    # è§£å‹å¤‡ä»½
    tar -xzf "${BACKUP_NAME}.tar.gz"
    cd "$BACKUP_NAME"
    
    # ç¡®è®¤æ¢å¤æ“ä½œ
    if [[ "${FORCE_RESTORE:-false}" != "true" ]]; then
        log "è¯·è®¾ç½® FORCE_RESTORE=true ç¯å¢ƒå˜é‡ç¡®è®¤æ¢å¤æ“ä½œ"
        exit 1
    fi
    
    # é€‰æ‹©æ€§æ¢å¤
    if [[ -n "$TARGET_NAMESPACE" ]]; then
        log "æ¢å¤æŒ‡å®šå‘½åç©ºé—´: $TARGET_NAMESPACE"
        
        # è¿‡æ»¤ç‰¹å®šå‘½åç©ºé—´çš„èµ„æº
        for file in *.yaml; do
            if grep -q "namespace: $TARGET_NAMESPACE" "$file"; then
                log "æ¢å¤ $file ä¸­çš„ $TARGET_NAMESPACE èµ„æº..."
                kubectl apply -f "$file" --namespace="$TARGET_NAMESPACE" || true
            fi
        done
    else
        log "æ¢å¤æ‰€æœ‰é…ç½®..."
        
        # æŒ‰é¡ºåºæ¢å¤èµ„æº
        RESTORE_ORDER=(
            "custom-resources.yaml"
            "persistent-volumes.yaml"
            "configmaps.yaml"
            "secrets.yaml"
            "services.yaml"
            "deployments.yaml"
            "statefulsets.yaml"
            "persistent-volume-claims.yaml"
            "ingress.yaml"
            "network-policies.yaml"
        )
        
        for file in "${RESTORE_ORDER[@]}"; do
            if [[ -f "$file" ]]; then
                log "æ¢å¤ $file..."
                kubectl apply -f "$file" || log "WARNING: æ¢å¤ $file æ—¶å‡ºç°é”™è¯¯"
                sleep 5  # ç­‰å¾…èµ„æºåˆ›å»º
            fi
        done
    fi
    
    # éªŒè¯æ¢å¤ç»“æœ
    log "éªŒè¯æ¢å¤ç»“æœ..."
    if [[ -n "$TARGET_NAMESPACE" ]]; then
        kubectl get all -n "$TARGET_NAMESPACE"
    else
        kubectl get namespaces
        kubectl get pods --all-namespaces | head -20
    fi
    
    # æ¸…ç†
    rm -rf "$RESTORE_DIR"
    
    log "Kubernetesé…ç½®æ¢å¤å®Œæˆ"

  # åº”ç”¨æ•°æ®æ¢å¤è„šæœ¬
  restore-app-data.sh: |
    #!/bin/bash
    set -euo pipefail
    
    if [[ $# -lt 1 ]]; then
        echo "ç”¨æ³•: $0 <backup-name> [restore-type]"
        echo "ç¤ºä¾‹: $0 app-data-backup-20241201-030000 config"
        echo "æ¢å¤ç±»å‹: config, uploads, redis, all"
        exit 1
    fi
    
    BACKUP_NAME="$1"
    RESTORE_TYPE="${2:-all}"
    RESTORE_DIR="/tmp/restore"
    
    log() {
        echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
    }
    
    mkdir -p "$RESTORE_DIR"
    cd "$RESTORE_DIR"
    
    log "å¼€å§‹åº”ç”¨æ•°æ®æ¢å¤: $BACKUP_NAME (ç±»å‹: $RESTORE_TYPE)"
    
    # ç¡®è®¤æ¢å¤æ“ä½œ
    if [[ "${FORCE_RESTORE:-false}" != "true" ]]; then
        log "è¯·è®¾ç½® FORCE_RESTORE=true ç¯å¢ƒå˜é‡ç¡®è®¤æ¢å¤æ“ä½œ"
        exit 1
    fi
    
    # æ¢å¤é…ç½®
    if [[ "$RESTORE_TYPE" == "config" ]] || [[ "$RESTORE_TYPE" == "all" ]]; then
        log "æ¢å¤åº”ç”¨é…ç½®..."
        
        # ä¸‹è½½é…ç½®å¤‡ä»½
        aws s3 cp "s3://${S3_BUCKET}/app-data/${BACKUP_NAME}-config.tar.gz" . || log "WARNING: é…ç½®å¤‡ä»½ä¸å­˜åœ¨"
        
        if [[ -f "${BACKUP_NAME}-config.tar.gz" ]]; then
            tar -xzf "${BACKUP_NAME}-config.tar.gz"
            
            # æ¢å¤ConfigMap
            if [[ -f "${BACKUP_NAME}-app-config.yaml" ]]; then
                kubectl apply -f "${BACKUP_NAME}-app-config.yaml"
                log "åº”ç”¨é…ç½®å·²æ¢å¤"
            fi
            
            # æ¢å¤Secret (éœ€è¦è°¨æ…å¤„ç†)
            if [[ -f "${BACKUP_NAME}-app-secrets.yaml" ]]; then
                log "WARNING: æ¢å¤Secretséœ€è¦äººå·¥ç¡®è®¤"
                # kubectl apply -f "${BACKUP_NAME}-app-secrets.yaml"
            fi
        fi
    fi
    
    # æ¢å¤ä¸Šä¼ æ–‡ä»¶
    if [[ "$RESTORE_TYPE" == "uploads" ]] || [[ "$RESTORE_TYPE" == "all" ]]; then
        log "æ¢å¤ä¸Šä¼ æ–‡ä»¶..."
        
        if kubectl get pvc app-data-pvc -n production &>/dev/null; then
            # ç›´æ¥ä»S3æ¢å¤åˆ°Pod
            POD_NAME=$(kubectl get pods -n production -l app=figma-frame-faithful -o jsonpath='{.items[0].metadata.name}')
            
            if [[ -n "$POD_NAME" ]]; then
                log "æ¢å¤æ–‡ä»¶åˆ° Pod: $POD_NAME"
                aws s3 cp "s3://${S3_BUCKET}/app-data/${BACKUP_NAME}-uploads.tar.gz" - | \
                  kubectl exec -n production "$POD_NAME" -- tar -xzf - -C /app/
                log "ä¸Šä¼ æ–‡ä»¶å·²æ¢å¤"
            fi
        fi
    fi
    
    # æ¢å¤Redisæ•°æ®
    if [[ "$RESTORE_TYPE" == "redis" ]] || [[ "$RESTORE_TYPE" == "all" ]]; then
        log "æ¢å¤Redisæ•°æ®..."
        
        if kubectl get service redis -n production &>/dev/null; then
            # ä¸‹è½½Rediså¤‡ä»½
            aws s3 cp "s3://${S3_BUCKET}/app-data/${BACKUP_NAME}-redis-dump.rdb" . || log "WARNING: Rediså¤‡ä»½ä¸å­˜åœ¨"
            
            if [[ -f "${BACKUP_NAME}-redis-dump.rdb" ]]; then
                REDIS_POD=$(kubectl get pods -n production -l app=redis -o jsonpath='{.items[0].metadata.name}')
                
                if [[ -n "$REDIS_POD" ]]; then
                    # åœæ­¢RedisæœåŠ¡
                    kubectl exec -n production "$REDIS_POD" -- redis-cli SHUTDOWN NOSAVE || true
                    sleep 5
                    
                    # å¤åˆ¶å¤‡ä»½æ–‡ä»¶
                    kubectl cp "${BACKUP_NAME}-redis-dump.rdb" "production/$REDIS_POD:/data/dump.rdb"
                    
                    # é‡å¯Redis Pod
                    kubectl delete pod -n production "$REDIS_POD"
                    kubectl wait --for=condition=Ready pod -l app=redis -n production --timeout=300s
                    
                    log "Redisæ•°æ®å·²æ¢å¤"
                fi
            fi
        fi
    fi
    
    # æ¸…ç†
    rm -rf "$RESTORE_DIR"
    
    log "åº”ç”¨æ•°æ®æ¢å¤å®Œæˆ"

  # ç›‘æ§æ•°æ®æ¢å¤è„šæœ¬
  restore-monitoring.sh: |
    #!/bin/bash
    set -euo pipefail
    
    if [[ $# -lt 1 ]]; then
        echo "ç”¨æ³•: $0 <backup-name> [component]"
        echo "ç¤ºä¾‹: $0 monitoring-backup-20241201-040000 prometheus"
        echo "ç»„ä»¶: prometheus, grafana, alertmanager, elasticsearch, all"
        exit 1
    fi
    
    BACKUP_NAME="$1"
    COMPONENT="${2:-all}"
    RESTORE_DIR="/tmp/restore"
    
    log() {
        echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
    }
    
    mkdir -p "$RESTORE_DIR"
    cd "$RESTORE_DIR"
    
    log "å¼€å§‹ç›‘æ§æ•°æ®æ¢å¤: $BACKUP_NAME (ç»„ä»¶: $COMPONENT)"
    
    # ç¡®è®¤æ¢å¤æ“ä½œ
    if [[ "${FORCE_RESTORE:-false}" != "true" ]]; then
        log "è¯·è®¾ç½® FORCE_RESTORE=true ç¯å¢ƒå˜é‡ç¡®è®¤æ¢å¤æ“ä½œ"
        exit 1
    fi
    
    # æ¢å¤é…ç½®
    log "ä¸‹è½½ç›‘æ§é…ç½®å¤‡ä»½..."
    aws s3 cp "s3://${S3_BUCKET}/monitoring/${BACKUP_NAME}-config.tar.gz" . || log "WARNING: é…ç½®å¤‡ä»½ä¸å­˜åœ¨"
    
    if [[ -f "${BACKUP_NAME}-config.tar.gz" ]]; then
        tar -xzf "${BACKUP_NAME}-config.tar.gz"
        cd "${BACKUP_NAME}"
        
        # æ¢å¤Grafanaé…ç½®
        if [[ "$COMPONENT" == "grafana" ]] || [[ "$COMPONENT" == "all" ]]; then
            if [[ -f "grafana-config.yaml" ]]; then
                log "æ¢å¤Grafanaé…ç½®..."
                kubectl apply -f grafana-config.yaml
                kubectl rollout restart deployment/grafana -n monitoring
            fi
        fi
        
        # æ¢å¤AlertManageré…ç½®
        if [[ "$COMPONENT" == "alertmanager" ]] || [[ "$COMPONENT" == "all" ]]; then
            if [[ -f "alertmanager-config.yaml" ]]; then
                log "æ¢å¤AlertManageré…ç½®..."
                kubectl apply -f alertmanager-config.yaml
                kubectl rollout restart deployment/alertmanager -n monitoring
            fi
        fi
        
        cd ..
    fi
    
    # æ¢å¤Prometheusæ•°æ®
    if [[ "$COMPONENT" == "prometheus" ]] || [[ "$COMPONENT" == "all" ]]; then
        log "æ¢å¤Prometheusæ•°æ®..."
        
        # ä¸‹è½½Prometheuså¿«ç…§
        aws s3 cp "s3://${S3_BUCKET}/monitoring/prometheus-${BACKUP_NAME}.tar.gz" . || log "WARNING: Prometheuså¤‡ä»½ä¸å­˜åœ¨"
        
        if [[ -f "prometheus-${BACKUP_NAME}.tar.gz" ]]; then
            PROMETHEUS_POD=$(kubectl get pods -n monitoring -l app=prometheus -o jsonpath='{.items[0].metadata.name}')
            
            if [[ -n "$PROMETHEUS_POD" ]]; then
                # åœæ­¢Prometheus
                kubectl scale statefulset/prometheus -n monitoring --replicas=0
                kubectl wait --for=delete pod -l app=prometheus -n monitoring --timeout=300s
                
                # æ¸…ç†ç°æœ‰æ•°æ®
                kubectl exec -n monitoring deployment/prometheus -- rm -rf /prometheus/* || true
                
                # æ¢å¤å¿«ç…§æ•°æ®
                kubectl cp "prometheus-${BACKUP_NAME}.tar.gz" "monitoring/$PROMETHEUS_POD:/tmp/"
                kubectl exec -n monitoring "$PROMETHEUS_POD" -- tar -xzf /tmp/prometheus-${BACKUP_NAME}.tar.gz -C /prometheus/
                
                # é‡å¯Prometheus
                kubectl scale statefulset/prometheus -n monitoring --replicas=1
                kubectl wait --for=condition=Ready pod -l app=prometheus -n monitoring --timeout=300s
                
                log "Prometheusæ•°æ®å·²æ¢å¤"
            fi
        fi
    fi
    
    # æ¢å¤Elasticsearchå¿«ç…§
    if [[ "$COMPONENT" == "elasticsearch" ]] || [[ "$COMPONENT" == "all" ]]; then
        log "æ¢å¤Elasticsearchå¿«ç…§..."
        
        if kubectl get statefulset elasticsearch-master -n logging &>/dev/null; then
            # æ¢å¤Elasticsearchå¿«ç…§
            kubectl exec -n logging statefulset/elasticsearch-master -- \
                curl -X POST "localhost:9200/_snapshot/backup_repository/snapshot-${BACKUP_NAME}/_restore" \
                -H 'Content-Type: application/json' \
                -d '{
                  "indices": "*",
                  "ignore_unavailable": true,
                  "include_global_state": false,
                  "rename_pattern": "(.+)",
                  "rename_replacement": "restored-$1"
                }' || log "WARNING: Elasticsearchå¿«ç…§æ¢å¤å¤±è´¥"
            
            log "Elasticsearchå¿«ç…§æ¢å¤å·²å¯åŠ¨"
        fi
    fi
    
    # æ¸…ç†
    rm -rf "$RESTORE_DIR"
    
    log "ç›‘æ§æ•°æ®æ¢å¤å®Œæˆ"

  # é€šç”¨æ¢å¤éªŒè¯è„šæœ¬
  verify-restore.sh: |
    #!/bin/bash
    set -euo pipefail
    
    RESTORE_TYPE="${1:-all}"
    
    log() {
        echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
    }
    
    log "å¼€å§‹æ¢å¤éªŒè¯: $RESTORE_TYPE"
    
    # éªŒè¯æ•°æ®åº“è¿æ¥
    if [[ "$RESTORE_TYPE" == "database" ]] || [[ "$RESTORE_TYPE" == "all" ]]; then
        log "éªŒè¯æ•°æ®åº“è¿æ¥..."
        if [[ -n "${SUPABASE_DB_URL:-}" ]]; then
            if psql "$SUPABASE_DB_URL" -c "SELECT 1;" &>/dev/null; then
                log "âœ… æ•°æ®åº“è¿æ¥æ­£å¸¸"
            else
                log "âŒ æ•°æ®åº“è¿æ¥å¤±è´¥"
            fi
        fi
    fi
    
    # éªŒè¯Kubernetesèµ„æº
    if [[ "$RESTORE_TYPE" == "kubernetes" ]] || [[ "$RESTORE_TYPE" == "all" ]]; then
        log "éªŒè¯Kubernetesèµ„æº..."
        
        # æ£€æŸ¥å…³é”®å‘½åç©ºé—´
        for ns in production staging monitoring logging backup; do
            if kubectl get namespace "$ns" &>/dev/null; then
                log "âœ… å‘½åç©ºé—´ $ns å­˜åœ¨"
            else
                log "âŒ å‘½åç©ºé—´ $ns ä¸å­˜åœ¨"
            fi
        done
        
        # æ£€æŸ¥å…³é”®åº”ç”¨
        if kubectl get deployment figma-frame-faithful -n production &>/dev/null; then
            log "âœ… ä¸»åº”ç”¨éƒ¨ç½²å­˜åœ¨"
        else
            log "âŒ ä¸»åº”ç”¨éƒ¨ç½²ä¸å­˜åœ¨"
        fi
    fi
    
    # éªŒè¯ç›‘æ§ç³»ç»Ÿ
    if [[ "$RESTORE_TYPE" == "monitoring" ]] || [[ "$RESTORE_TYPE" == "all" ]]; then
        log "éªŒè¯ç›‘æ§ç³»ç»Ÿ..."
        
        # æ£€æŸ¥Prometheus
        if kubectl exec -n monitoring deployment/prometheus -- \
             wget -q -O- http://localhost:9090/-/healthy 2>/dev/null | grep -q "Prometheus is Healthy"; then
            log "âœ… Prometheus å¥åº·çŠ¶æ€æ­£å¸¸"
        else
            log "âŒ Prometheus å¥åº·æ£€æŸ¥å¤±è´¥"
        fi
        
        # æ£€æŸ¥Grafana
        if kubectl exec -n monitoring deployment/grafana -- \
             curl -s http://localhost:3000/api/health 2>/dev/null | grep -q "ok"; then
            log "âœ… Grafana å¥åº·çŠ¶æ€æ­£å¸¸"
        else
            log "âŒ Grafana å¥åº·æ£€æŸ¥å¤±è´¥"
        fi
    fi
    
    log "æ¢å¤éªŒè¯å®Œæˆ"

---
# ğŸ”„ æ‰‹åŠ¨æ¢å¤ä½œä¸šæ¨¡æ¿
apiVersion: batch/v1
kind: Job
metadata:
  name: manual-restore-job
  namespace: backup
  labels:
    app: backup-system
    component: restore
spec:
  activeDeadlineSeconds: 7200  # 2å°æ—¶è¶…æ—¶
  backoffLimit: 2
  template:
    metadata:
      labels:
        app: backup-system
        component: restore
    spec:
      serviceAccountName: backup-service
      restartPolicy: Never
      containers:
      - name: restore
        image: bitnami/kubectl:latest
        command:
        - /bin/bash
        - -c
        - |
          # å®‰è£…å¿…è¦å·¥å…·
          apt-get update && apt-get install -y \
            curl wget unzip awscli postgresql-client-14 redis-tools
          
          # å®‰è£…Supabase CLI
          curl -fsSL https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.tar.gz | \
            tar -xz --strip-components=1 -C /usr/local/bin
          
          # è®¾ç½®ç¯å¢ƒå˜é‡
          export AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
          export AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
          export AWS_DEFAULT_REGION="$AWS_DEFAULT_REGION"
          
          # ç­‰å¾…æ‰‹åŠ¨æ“ä½œæŒ‡ä»¤
          echo "æ¢å¤ä½œä¸šå·²å‡†å¤‡å°±ç»ª"
          echo "è¯·ä½¿ç”¨ kubectl exec è¿›å…¥å®¹å™¨æ‰§è¡Œæ¢å¤è„šæœ¬"
          echo ""
          echo "å¯ç”¨çš„æ¢å¤è„šæœ¬:"
          echo "  /scripts/restore-database.sh <backup-name>"
          echo "  /scripts/restore-k8s-config.sh <backup-name>"
          echo "  /scripts/restore-app-data.sh <backup-name> [type]"
          echo "  /scripts/restore-monitoring.sh <backup-name> [component]"
          echo "  /scripts/verify-restore.sh [type]"
          echo ""
          echo "ç¤ºä¾‹:"
          echo "  kubectl exec -it manual-restore-job-xxx -n backup -- /scripts/restore-database.sh supabase-backup-20241201-020000"
          echo ""
          
          # ä¿æŒå®¹å™¨è¿è¡Œï¼Œç­‰å¾…æ‰‹åŠ¨æ“ä½œ
          sleep 7200
        env:
        - name: FORCE_RESTORE
          value: "false"  # é»˜è®¤å…³é—­ï¼Œéœ€è¦æ‰‹åŠ¨è®¾ç½®
        envFrom:
        - secretRef:
            name: aws-credentials
        - secretRef:
            name: supabase-credentials
            optional: true
        - configMapRef:
            name: backup-config
        volumeMounts:
        - name: restore-scripts
          mountPath: /scripts
          readOnly: true
        resources:
          requests:
            memory: "512Mi"
            cpu: "200m"
          limits:
            memory: "1Gi"
            cpu: "500m"
      volumes:
      - name: restore-scripts
        configMap:
          name: restore-scripts
          defaultMode: 0755