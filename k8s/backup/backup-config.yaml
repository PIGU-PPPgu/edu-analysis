# ğŸ”„ å¤‡ä»½å’Œæ¢å¤ç³»ç»Ÿé…ç½®
# ä¸ºç”Ÿäº§ç¯å¢ƒæä¾›å…¨é¢çš„æ•°æ®å¤‡ä»½å’Œç¾éš¾æ¢å¤èƒ½åŠ›

apiVersion: v1
kind: Namespace
metadata:
  name: backup
  labels:
    name: backup
    tier: infrastructure

---
# ğŸ“‹ ConfigMap - å¤‡ä»½é…ç½®
apiVersion: v1
kind: ConfigMap
metadata:
  name: backup-config
  namespace: backup
  labels:
    app: backup-system
data:
  # å¤‡ä»½é…ç½®æ–‡ä»¶
  backup.conf: |
    # å¤‡ä»½ç³»ç»Ÿé…ç½®
    BACKUP_RETENTION_DAYS=30
    BACKUP_COMPRESSION=gzip
    BACKUP_ENCRYPTION=true
    
    # æ•°æ®åº“å¤‡ä»½é…ç½®
    DB_BACKUP_ENABLED=true
    DB_BACKUP_SCHEDULE="0 2 * * *"  # æ¯å¤©å‡Œæ™¨2ç‚¹
    DB_BACKUP_RETENTION=7
    
    # åº”ç”¨æ•°æ®å¤‡ä»½é…ç½®
    APP_BACKUP_ENABLED=true
    APP_BACKUP_SCHEDULE="0 3 * * *"  # æ¯å¤©å‡Œæ™¨3ç‚¹
    APP_BACKUP_RETENTION=7
    
    # ç›‘æ§æ•°æ®å¤‡ä»½é…ç½®
    MONITORING_BACKUP_ENABLED=true
    MONITORING_BACKUP_SCHEDULE="0 4 * * *"  # æ¯å¤©å‡Œæ™¨4ç‚¹
    MONITORING_BACKUP_RETENTION=14
    
    # é…ç½®æ–‡ä»¶å¤‡ä»½
    CONFIG_BACKUP_ENABLED=true
    CONFIG_BACKUP_SCHEDULE="0 1 * * 0"  # æ¯å‘¨æ—¥å‡Œæ™¨1ç‚¹
    CONFIG_BACKUP_RETENTION=30
    
    # å­˜å‚¨é…ç½®
    BACKUP_STORAGE_TYPE=s3
    S3_BUCKET=figma-frame-faithful-backups
    S3_REGION=us-east-1
    S3_STORAGE_CLASS=STANDARD_IA
    
    # é€šçŸ¥é…ç½®
    NOTIFICATION_ENABLED=true
    NOTIFICATION_WEBHOOK=https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK
    NOTIFICATION_EMAIL=ops@figma-frame-faithful.com

  # Supabaseæ•°æ®åº“å¤‡ä»½è„šæœ¬
  backup-supabase.sh: |
    #!/bin/bash
    set -euo pipefail
    
    # é…ç½®å˜é‡
    BACKUP_NAME="supabase-backup-$(date +%Y%m%d-%H%M%S)"
    BACKUP_DIR="/tmp/backups"
    
    log() {
        echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
    }
    
    # åˆ›å»ºå¤‡ä»½ç›®å½•
    mkdir -p "$BACKUP_DIR"
    
    log "å¼€å§‹Supabaseæ•°æ®åº“å¤‡ä»½..."
    
    # ä½¿ç”¨Supabase CLIè¿›è¡Œå¤‡ä»½
    if command -v supabase &> /dev/null; then
        log "ä½¿ç”¨Supabase CLIå¤‡ä»½..."
        
        # å¤‡ä»½æ•°æ®åº“ç»“æ„
        supabase db dump --schema-only > "$BACKUP_DIR/${BACKUP_NAME}-schema.sql"
        
        # å¤‡ä»½æ•°æ®
        supabase db dump --data-only > "$BACKUP_DIR/${BACKUP_NAME}-data.sql"
        
        # å¤‡ä»½å­˜å‚¨æ¡¶æ–‡ä»¶ï¼ˆå¦‚æœæœ‰ï¼‰
        if [[ "${BACKUP_STORAGE:-true}" == "true" ]]; then
            log "å¤‡ä»½å­˜å‚¨æ¡¶æ–‡ä»¶..."
            supabase storage ls --recursive > "$BACKUP_DIR/${BACKUP_NAME}-storage-list.txt"
        fi
        
    else
        # ä½¿ç”¨pg_dumpå¤‡ä»½ï¼ˆå¦‚æœæœ‰ç›´æ¥æ•°æ®åº“è®¿é—®ï¼‰
        if [[ -n "${SUPABASE_DB_URL:-}" ]]; then
            log "ä½¿ç”¨pg_dumpå¤‡ä»½..."
            pg_dump "$SUPABASE_DB_URL" --schema-only > "$BACKUP_DIR/${BACKUP_NAME}-schema.sql"
            pg_dump "$SUPABASE_DB_URL" --data-only > "$BACKUP_DIR/${BACKUP_NAME}-data.sql"
        else
            log "ERROR: æ— æ³•æ‰¾åˆ°Supabase CLIæˆ–æ•°æ®åº“è¿æ¥ä¿¡æ¯"
            exit 1
        fi
    fi
    
    # å‹ç¼©å¤‡ä»½æ–‡ä»¶
    log "å‹ç¼©å¤‡ä»½æ–‡ä»¶..."
    cd "$BACKUP_DIR"
    tar -czf "${BACKUP_NAME}.tar.gz" ${BACKUP_NAME}*.sql ${BACKUP_NAME}*.txt 2>/dev/null || true
    
    # ä¸Šä¼ åˆ°äº‘å­˜å‚¨
    log "ä¸Šä¼ å¤‡ä»½åˆ°äº‘å­˜å‚¨..."
    aws s3 cp "${BACKUP_NAME}.tar.gz" "s3://${S3_BUCKET}/database/" \
        --storage-class "$S3_STORAGE_CLASS" \
        --metadata "backup-type=database,backup-date=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    
    # æ¸…ç†æœ¬åœ°å¤‡ä»½æ–‡ä»¶
    rm -f ${BACKUP_NAME}*
    
    log "Supabaseæ•°æ®åº“å¤‡ä»½å®Œæˆ: ${BACKUP_NAME}.tar.gz"

  # Kubernetesé…ç½®å¤‡ä»½è„šæœ¬
  backup-k8s-config.sh: |
    #!/bin/bash
    set -euo pipefail
    
    BACKUP_NAME="k8s-config-backup-$(date +%Y%m%d-%H%M%S)"
    BACKUP_DIR="/tmp/backups"
    
    log() {
        echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
    }
    
    mkdir -p "$BACKUP_DIR/$BACKUP_NAME"
    
    log "å¼€å§‹Kubernetesé…ç½®å¤‡ä»½..."
    
    # å¤‡ä»½æ‰€æœ‰ConfigMaps
    log "å¤‡ä»½ConfigMaps..."
    kubectl get configmaps --all-namespaces -o yaml > "$BACKUP_DIR/$BACKUP_NAME/configmaps.yaml"
    
    # å¤‡ä»½æ‰€æœ‰Secretsï¼ˆæ•æ„Ÿä¿¡æ¯å°†è¢«åŠ å¯†å­˜å‚¨ï¼‰
    log "å¤‡ä»½Secrets..."
    kubectl get secrets --all-namespaces -o yaml > "$BACKUP_DIR/$BACKUP_NAME/secrets.yaml"
    
    # å¤‡ä»½Deployments
    log "å¤‡ä»½Deployments..."
    kubectl get deployments --all-namespaces -o yaml > "$BACKUP_DIR/$BACKUP_NAME/deployments.yaml"
    
    # å¤‡ä»½Services
    log "å¤‡ä»½Services..."
    kubectl get services --all-namespaces -o yaml > "$BACKUP_DIR/$BACKUP_NAME/services.yaml"
    
    # å¤‡ä»½Ingress
    log "å¤‡ä»½Ingress..."
    kubectl get ingress --all-namespaces -o yaml > "$BACKUP_DIR/$BACKUP_NAME/ingress.yaml"
    
    # å¤‡ä»½PersistentVolumeså’ŒPersistentVolumeClaims
    log "å¤‡ä»½å­˜å‚¨é…ç½®..."
    kubectl get pv -o yaml > "$BACKUP_DIR/$BACKUP_NAME/persistent-volumes.yaml"
    kubectl get pvc --all-namespaces -o yaml > "$BACKUP_DIR/$BACKUP_NAME/persistent-volume-claims.yaml"
    
    # å¤‡ä»½StatefulSets
    log "å¤‡ä»½StatefulSets..."
    kubectl get statefulsets --all-namespaces -o yaml > "$BACKUP_DIR/$BACKUP_NAME/statefulsets.yaml"
    
    # å¤‡ä»½è‡ªå®šä¹‰èµ„æº
    log "å¤‡ä»½è‡ªå®šä¹‰èµ„æº..."
    kubectl get crd -o yaml > "$BACKUP_DIR/$BACKUP_NAME/custom-resources.yaml"
    
    # å¤‡ä»½ç½‘ç»œç­–ç•¥
    log "å¤‡ä»½ç½‘ç»œç­–ç•¥..."
    kubectl get networkpolicies --all-namespaces -o yaml > "$BACKUP_DIR/$BACKUP_NAME/network-policies.yaml"
    
    # åˆ›å»ºå¤‡ä»½æ¸…å•
    cat > "$BACKUP_DIR/$BACKUP_NAME/backup-manifest.yaml" <<EOF
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: backup-manifest
      namespace: backup
    data:
      backup-date: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
      backup-name: "$BACKUP_NAME"
      kubernetes-version: "$(kubectl version --short --client | grep Client | cut -d' ' -f3)"
      cluster-info: |
    $(kubectl cluster-info | sed 's/^/    /')
    EOF
    
    # å‹ç¼©å¤‡ä»½
    log "å‹ç¼©å¤‡ä»½æ–‡ä»¶..."
    cd "$BACKUP_DIR"
    tar -czf "${BACKUP_NAME}.tar.gz" "$BACKUP_NAME/"
    
    # ä¸Šä¼ åˆ°äº‘å­˜å‚¨
    log "ä¸Šä¼ é…ç½®å¤‡ä»½åˆ°äº‘å­˜å‚¨..."
    aws s3 cp "${BACKUP_NAME}.tar.gz" "s3://${S3_BUCKET}/kubernetes-config/" \
        --storage-class "$S3_STORAGE_CLASS" \
        --metadata "backup-type=kubernetes-config,backup-date=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    
    # æ¸…ç†æœ¬åœ°æ–‡ä»¶
    rm -rf "$BACKUP_NAME" "${BACKUP_NAME}.tar.gz"
    
    log "Kubernetesé…ç½®å¤‡ä»½å®Œæˆ: ${BACKUP_NAME}.tar.gz"

  # åº”ç”¨æ•°æ®å¤‡ä»½è„šæœ¬
  backup-app-data.sh: |
    #!/bin/bash
    set -euo pipefail
    
    BACKUP_NAME="app-data-backup-$(date +%Y%m%d-%H%M%S)"
    BACKUP_DIR="/tmp/backups"
    
    log() {
        echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
    }
    
    mkdir -p "$BACKUP_DIR"
    
    log "å¼€å§‹åº”ç”¨æ•°æ®å¤‡ä»½..."
    
    # å¤‡ä»½åº”ç”¨ä¸Šä¼ çš„æ–‡ä»¶
    log "å¤‡ä»½åº”ç”¨æ–‡ä»¶æ•°æ®..."
    if kubectl get pvc app-data-pvc -n production &>/dev/null; then
        kubectl exec -n production deployment/figma-frame-faithful -- tar -czf - /app/uploads 2>/dev/null | \
            aws s3 cp - "s3://${S3_BUCKET}/app-data/${BACKUP_NAME}-uploads.tar.gz" \
            --storage-class "$S3_STORAGE_CLASS"
    fi
    
    # å¤‡ä»½åº”ç”¨é…ç½®æ–‡ä»¶
    log "å¤‡ä»½åº”ç”¨é…ç½®..."
    kubectl get configmap app-config -n production -o yaml > "$BACKUP_DIR/${BACKUP_NAME}-app-config.yaml"
    kubectl get secret app-secrets -n production -o yaml > "$BACKUP_DIR/${BACKUP_NAME}-app-secrets.yaml"
    
    # å¤‡ä»½ç”¨æˆ·ä¼šè¯æ•°æ®ï¼ˆå¦‚æœä½¿ç”¨Redisï¼‰
    if kubectl get service redis -n production &>/dev/null; then
        log "å¤‡ä»½Redisä¼šè¯æ•°æ®..."
        kubectl exec -n production service/redis -- redis-cli BGSAVE
        sleep 5  # ç­‰å¾…å¤‡ä»½å®Œæˆ
        kubectl cp production/redis-pod:/data/dump.rdb "$BACKUP_DIR/${BACKUP_NAME}-redis-dump.rdb"
    fi
    
    # å‹ç¼©æœ¬åœ°å¤‡ä»½æ–‡ä»¶
    if [[ -f "$BACKUP_DIR/${BACKUP_NAME}-app-config.yaml" ]]; then
        cd "$BACKUP_DIR"
        tar -czf "${BACKUP_NAME}-config.tar.gz" ${BACKUP_NAME}*.yaml ${BACKUP_NAME}*.rdb 2>/dev/null || true
        
        # ä¸Šä¼ é…ç½®å¤‡ä»½
        aws s3 cp "${BACKUP_NAME}-config.tar.gz" "s3://${S3_BUCKET}/app-data/" \
            --storage-class "$S3_STORAGE_CLASS"
        
        # æ¸…ç†æœ¬åœ°æ–‡ä»¶
        rm -f ${BACKUP_NAME}*
    fi
    
    log "åº”ç”¨æ•°æ®å¤‡ä»½å®Œæˆ"

  # ç›‘æ§æ•°æ®å¤‡ä»½è„šæœ¬
  backup-monitoring.sh: |
    #!/bin/bash
    set -euo pipefail
    
    BACKUP_NAME="monitoring-backup-$(date +%Y%m%d-%H%M%S)"
    BACKUP_DIR="/tmp/backups"
    
    log() {
        echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
    }
    
    mkdir -p "$BACKUP_DIR/$BACKUP_NAME"
    
    log "å¼€å§‹ç›‘æ§æ•°æ®å¤‡ä»½..."
    
    # å¤‡ä»½Prometheusæ•°æ®
    if kubectl get statefulset prometheus -n monitoring &>/dev/null; then
        log "åˆ›å»ºPrometheusæ•°æ®å¿«ç…§..."
        kubectl exec -n monitoring statefulset/prometheus -- \
            curl -XPOST http://localhost:9090/api/v1/admin/tsdb/snapshot
        
        # è·å–æœ€æ–°å¿«ç…§
        SNAPSHOT=$(kubectl exec -n monitoring statefulset/prometheus -- \
            ls -t /prometheus/snapshots/ | head -1)
        
        if [[ -n "$SNAPSHOT" ]]; then
            log "å¤‡ä»½Prometheuså¿«ç…§: $SNAPSHOT"
            kubectl exec -n monitoring statefulset/prometheus -- \
                tar -czf - -C /prometheus/snapshots "$SNAPSHOT" | \
                aws s3 cp - "s3://${S3_BUCKET}/monitoring/prometheus-${BACKUP_NAME}.tar.gz" \
                --storage-class "$S3_STORAGE_CLASS"
        fi
    fi
    
    # å¤‡ä»½Grafanaé…ç½®
    if kubectl get deployment grafana -n monitoring &>/dev/null; then
        log "å¤‡ä»½Grafanaé…ç½®..."
        kubectl get configmap grafana-config -n monitoring -o yaml > "$BACKUP_DIR/$BACKUP_NAME/grafana-config.yaml"
        kubectl get configmap grafana-dashboards -n monitoring -o yaml > "$BACKUP_DIR/$BACKUP_NAME/grafana-dashboards.yaml"
    fi
    
    # å¤‡ä»½AlertManageré…ç½®
    if kubectl get deployment alertmanager -n monitoring &>/dev/null; then
        log "å¤‡ä»½AlertManageré…ç½®..."
        kubectl get configmap alertmanager-config -n monitoring -o yaml > "$BACKUP_DIR/$BACKUP_NAME/alertmanager-config.yaml"
    fi
    
    # å¤‡ä»½Elasticsearchå¿«ç…§
    if kubectl get statefulset elasticsearch-master -n logging &>/dev/null; then
        log "åˆ›å»ºElasticsearchå¿«ç…§..."
        
        # åˆ›å»ºå¿«ç…§ä»“åº“ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        kubectl exec -n logging statefulset/elasticsearch-master -- \
            curl -X PUT "localhost:9200/_snapshot/backup_repository" \
            -H 'Content-Type: application/json' \
            -d '{
              "type": "fs",
              "settings": {
                "location": "/backup",
                "compress": true
              }
            }' || true
        
        # åˆ›å»ºå¿«ç…§
        kubectl exec -n logging statefulset/elasticsearch-master -- \
            curl -X PUT "localhost:9200/_snapshot/backup_repository/snapshot-${BACKUP_NAME}" \
            -H 'Content-Type: application/json' \
            -d '{
              "indices": "*",
              "ignore_unavailable": true,
              "include_global_state": false
            }'
    fi
    
    # å‹ç¼©å¹¶ä¸Šä¼ é…ç½®æ–‡ä»¶
    if [[ -d "$BACKUP_DIR/$BACKUP_NAME" ]] && [[ -n "$(ls -A "$BACKUP_DIR/$BACKUP_NAME" 2>/dev/null)" ]]; then
        cd "$BACKUP_DIR"
        tar -czf "${BACKUP_NAME}-config.tar.gz" "$BACKUP_NAME/"
        
        aws s3 cp "${BACKUP_NAME}-config.tar.gz" "s3://${S3_BUCKET}/monitoring/" \
            --storage-class "$S3_STORAGE_CLASS"
        
        rm -rf "$BACKUP_NAME" "${BACKUP_NAME}-config.tar.gz"
    fi
    
    log "ç›‘æ§æ•°æ®å¤‡ä»½å®Œæˆ"

---
# ğŸ” ServiceAccount - å¤‡ä»½ç³»ç»Ÿ
apiVersion: v1
kind: ServiceAccount
metadata:
  name: backup-service
  namespace: backup
  labels:
    app: backup-system

---
# ğŸ”‘ ClusterRole - å¤‡ä»½æƒé™
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: backup-cluster-role
  labels:
    app: backup-system
rules:
# è¯»å–æ‰€æœ‰èµ„æºç”¨äºå¤‡ä»½
- apiGroups: [""]
  resources: ["*"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["*"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["extensions", "networking.k8s.io"]
  resources: ["*"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["storage.k8s.io"]
  resources: ["*"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apiextensions.k8s.io"]
  resources: ["*"]
  verbs: ["get", "list", "watch"]
# Execæƒé™ç”¨äºæ‰§è¡Œå¤‡ä»½å‘½ä»¤
- apiGroups: [""]
  resources: ["pods/exec"]
  verbs: ["create"]
# å¿«ç…§åˆ›å»ºæƒé™
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
  resourceNames: ["prometheus-*", "elasticsearch-*"]

---
# ğŸ”— ClusterRoleBinding - å¤‡ä»½æƒé™ç»‘å®š
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: backup-cluster-role-binding
  labels:
    app: backup-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: backup-cluster-role
subjects:
- kind: ServiceAccount
  name: backup-service
  namespace: backup

---
# ğŸ” Secret - AWSå‡­è¯
apiVersion: v1
kind: Secret
metadata:
  name: aws-credentials
  namespace: backup
  labels:
    app: backup-system
type: Opaque
data:
  # è¯·æ›¿æ¢ä¸ºå®é™…çš„base64ç¼–ç çš„AWSå‡­è¯
  AWS_ACCESS_KEY_ID: WU9VUl9BV1NfQUNDRVNTX0tFWV9JRA==  # YOUR_AWS_ACCESS_KEY_ID
  AWS_SECRET_ACCESS_KEY: WU9VUl9BV1NfU0VDUkVUX0FDQ0VTU19LRVk=  # YOUR_AWS_SECRET_ACCESS_KEY
  AWS_DEFAULT_REGION: dXMtZWFzdC0x  # us-east-1

---
# ğŸ” Secret - é€šçŸ¥é…ç½®
apiVersion: v1
kind: Secret
metadata:
  name: backup-notifications
  namespace: backup
  labels:
    app: backup-system
type: Opaque
data:
  SLACK_WEBHOOK_URL: aHR0cHM6Ly9ob29rcy5zbGFjay5jb20vc2VydmljZXMvWU9VUi9TTEFDS1dFQkhPT0s=  # https://hooks.slack.com/services/YOUR/SLACKWEBHOOK
  EMAIL_SMTP_PASSWORD: WU9VUl9FTUFJTF9QQVNTV09SRA==  # YOUR_EMAIL_PASSWORD