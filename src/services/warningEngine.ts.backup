/**
 * 预警引擎核心实现
 * 负责自动执行预警规则，生成预警记录，并记录执行过程
 */

import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

// 基础类型定义
type ExecutionType = 'manual' | 'auto' | 'scheduled';

interface WarningRule {
  id: string;
  name: string;
  description: string;
  conditions: Record<string, any>;
  severity: 'low' | 'medium' | 'high';
  scope?: string;
  category?: string;
  metadata?: Record<string, any>;
}

// 规则执行上下文
interface RuleExecutionContext {
  rule: WarningRule;
  executionId: string;
  ruleExecutionId?: string;
  startTime: number;
}

// 学生匹配结果
interface StudentMatch {
  studentId: string;
  studentData: Record<string, any>;
  matchedConditions: Record<string, any>;
  severity: 'low' | 'medium' | 'high';
  shouldGenerateWarning: boolean;
  skipReason?: string;
}

// 规则执行结果
interface RuleExecutionResult {
  ruleId: string;
  affectedStudents: StudentMatch[];
  executionTimeMs: number;
  sqlExecuted?: string;
  success: boolean;
  error?: string;
}

// 引擎执行结果
interface EngineExecutionResult {
  executionId: string;
  totalRulesProcessed: number;
  totalStudentsMatched: number;
  totalWarningsGenerated: number;
  totalExecutionTimeMs: number;
  ruleResults: RuleExecutionResult[];
  success: boolean;
  error?: string;
}

// Mock functions for missing services
const getWarningRules = async (filter: { is_active: boolean }): Promise<WarningRule[]> => {
  const { data, error } = await supabase
    .from('warning_rules')
    .select('*')
    .eq('is_active', filter.is_active);
  
  if (error) throw error;
  return data || [];
};

const startWarningExecution = async (
  executionType: ExecutionType,
  triggerEvent?: string,
  ruleCount?: number
): Promise<{ id: string } | null> => {
  const { data, error } = await supabase
    .from('warning_executions')
    .insert({
      execution_type: executionType,
      trigger_event: triggerEvent,
      rules_count: ruleCount,
      status: 'running'
    })
    .select('id')
    .single();
  
  if (error) {
    console.error('创建执行记录失败:', error);
    return null;
  }
  
  return data;
};

const completeWarningExecution = async (executionId: string, result: any): Promise<void> => {
  const { error } = await supabase
    .from('warning_executions')
    .update({
      status: result.success ? 'completed' : 'failed',
      completed_at: new Date().toISOString(),
      result: result
    })
    .eq('id', executionId);
  
  if (error) {
    console.error('完成执行记录失败:', error);
  }
};

const recordRuleExecution = async (
  executionId: string,
  ruleId: string,
  ruleData: Record<string, any>,
  result: Record<string, any>
): Promise<string | null> => {
  const { data, error } = await supabase
    .from('rule_executions')
    .insert({
      execution_id: executionId,
      rule_id: ruleId,
      rule_data: ruleData,
      result: result
    })
    .select('id')
    .single();
  
  if (error) {
    console.error('记录规则执行失败:', error);
    return null;
  }
  
  return data?.id || null;
};

const recordExecutionResult = async (
  ruleExecutionId: string,
  studentId: string,
  studentData: Record<string, any>,
  matchedConditions: Record<string, any>,
  severity: string,
  warningGenerated: boolean,
  warningRecordId?: string,
  skipReason?: string
): Promise<void> => {
  const { error } = await supabase
    .from('execution_results')
    .insert({
      rule_execution_id: ruleExecutionId,
      student_id: studentId,
      student_data: studentData,
      matched_conditions: matchedConditions,
      severity: severity,
      warning_generated: warningGenerated,
      warning_record_id: warningRecordId,
      skip_reason: skipReason
    });
  
  if (error) {
    console.error('记录执行结果失败:', error);
  }
};

/**
 * 预警引擎主类
 */
export class WarningEngine {
  private isRunning: boolean = false;
  private executionId: string | null = null;

  /**
   * 执行所有活跃的预警规则
   */
  async executeAllRules(
    executionType: ExecutionType = 'manual',
    triggerEvent?: string
  ): Promise<EngineExecutionResult> {
    if (this.isRunning) {
      throw new Error('预警引擎正在运行中，请稍后再试');
    }

    this.isRunning = true;
    const startTime = Date.now();

    try {
      // 获取所有活跃的预警规则
      const activeRules = await getWarningRules({ is_active: true });
      
      if (activeRules.length === 0) {
        throw new Error('没有找到活跃的预警规则');
      }

      // 开始执行记录
      const execution = await startWarningExecution(
        executionType,
        triggerEvent,
        activeRules.length
      );

      if (!execution) {
        throw new Error('创建执行记录失败');
      }

      this.executionId = execution.id;

      // 执行每个规则
      const ruleResults: RuleExecutionResult[] = [];
      let totalStudentsMatched = 0;
      let totalWarningsGenerated = 0;

      for (const rule of activeRules) {
        try {
          const result = await this.executeRule(rule, execution.id);
          ruleResults.push(result);
          totalStudentsMatched += result.affectedStudents.length;
          totalWarningsGenerated += result.affectedStudents.filter(s => s.shouldGenerateWarning).length;
        } catch (error) {
          console.error(`规则 ${rule.id} 执行失败:`, error);
          ruleResults.push({
            ruleId: rule.id,
            affectedStudents: [],
            executionTimeMs: 0,
            success: false,
            error: String(error)
          });
        }
      }

      const totalExecutionTime = Date.now() - startTime;
      const success = ruleResults.every(r => r.success);

      // 完成执行记录
      const finalResult = {
        executionId: execution.id,
        totalRulesProcessed: activeRules.length,
        totalStudentsMatched,
        totalWarningsGenerated,
        totalExecutionTimeMs: totalExecutionTime,
        ruleResults,
        success
      };

      await completeWarningExecution(execution.id, finalResult);

      return finalResult;
    } catch (error) {
      const totalExecutionTime = Date.now() - startTime;

      // 如果有执行ID，标记为失败
      if (this.executionId) {
        await completeWarningExecution(this.executionId, {
          success: false,
          error: String(error),
          totalExecutionTimeMs: totalExecutionTime
        });
      }

      throw error;
    } finally {
      this.isRunning = false;
      this.executionId = null;
    }
  }

  /**
   * 执行单个预警规则
   */
  private async executeRule(
    rule: WarningRule,
    executionId: string
  ): Promise<RuleExecutionResult> {
    const startTime = Date.now();

    try {
      // 记录规则执行开始
      const ruleExecutionId = await recordRuleExecution(
        executionId,
        rule.id,
        {
          name: rule.name,
          description: rule.description,
          conditions: rule.conditions,
          severity: rule.severity,
          scope: rule.scope,
          category: rule.category
        },
        {
          affectedStudentsCount: 0,
          newWarningsCount: 0,
          status: 'running'
        }
      );

      if (!ruleExecutionId) {
        throw new Error('创建规则执行记录失败');
      }

      // 根据规则类型执行不同的逻辑
      const matches = await this.evaluateRule(rule);
      const executionTime = Date.now() - startTime;

      // 生成预警记录
      let warningsGenerated = 0;
      for (const match of matches) {
        if (match.shouldGenerateWarning) {
          const warningRecordId = await this.createWarningRecord(rule, match);
          
          // 记录执行结果
          await recordExecutionResult(
            ruleExecutionId,
            match.studentId,
            match.studentData,
            match.matchedConditions,
            match.severity,
            !!warningRecordId,
            warningRecordId,
            match.skipReason
          );

          if (warningRecordId) {
            warningsGenerated++;
          }
        } else {
          // 记录跳过的结果
          await recordExecutionResult(
            ruleExecutionId,
            match.studentId,
            match.studentData,
            match.matchedConditions,
            match.severity,
            false,
            undefined,
            match.skipReason
          );
        }
      }

      // 更新规则执行记录
      await recordRuleExecution(
        executionId,
        rule.id,
        {
          name: rule.name,
          conditions: rule.conditions,
          severity: rule.severity
        },
        {
          affectedStudentsCount: matches.length,
          newWarningsCount: warningsGenerated,
          executionTimeMs: executionTime,
          status: 'completed'
        }
      );

      return {
        ruleId: rule.id,
        affectedStudents: matches,
        executionTimeMs: executionTime,
        success: true
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      
      // 记录失败的规则执行
      await recordRuleExecution(
        executionId,
        rule.id,
        { name: rule.name, conditions: rule.conditions },
        {
          affectedStudentsCount: 0,
          newWarningsCount: 0,
          executionTimeMs: executionTime,
          status: 'failed',
          errorMessage: String(error)
        }
      );

      throw error;
    }
  }

  /**
   * 评估规则条件，找出匹配的学生
   */
  private async evaluateRule(rule: WarningRule): Promise<StudentMatch[]> {
    const matches: StudentMatch[] = [];

    try {
      // 检查规则条件的类型
      if (!rule.conditions) {
        throw new Error('规则条件为空');
      }

      // 根据不同的条件类型执行不同的评估逻辑
      if (rule.conditions.scenario) {
        // 处理场景化规则（来自简化构建器）
        matches.push(...await this.evaluateScenarioRule(rule));
      } else {
        // 处理传统规则
        matches.push(...await this.evaluateTraditionalRule(rule));
      }

      return matches;
    } catch (error) {
      console.error(`评估规则 ${rule.id} 失败:`, error);
      return [];
    }
  }

  /**
   * 评估场景化规则
   */
  private async evaluateScenarioRule(rule: WarningRule): Promise<StudentMatch[]> {
    const matches: StudentMatch[] = [];
    
    try {
      const conditions = rule.conditions;
      
      if (conditions.scenario === 'grade_fail') {
        // 成绩不及格场景
        return this.evaluateGradeFailScenario(rule);
      } else if (conditions.scenario === 'grade_decline') {
        // 成绩下降场景
        return this.evaluateGradeDeclineScenario(rule);
      } else if (conditions.scenario === 'exam_regression') {
        // 考试退步场景
        return this.evaluateExamRegressionScenario(rule);
      } else if (conditions.scenario === 'homework_default') {
        // 作业拖欠场景
        return this.evaluateHomeworkDefaultScenario(rule);
      } else if (conditions.scenario === 'consecutive_fail') {
        // 连续失败场景
        return this.evaluateConsecutiveFailScenario(rule);
      } else if (conditions.scenario === 'class_warning') {
        // 班级预警场景
        return this.evaluateClassWarningScenario(rule);
      }

      return matches;
    } catch (error) {
      console.error('评估场景化规则失败:', error);
      return matches;
    }
  }

  /**
   * 评估成绩不及格场景
   */
  private async evaluateGradeFailScenario(rule: WarningRule): Promise<StudentMatch[]> {
    const matches: StudentMatch[] = [];
    const parameters = rule.metadata?.scenario?.parameters || {};
    const threshold = parameters.threshold || 60;
    const subjects = parameters.subjects || ['total'];

    try {
      // 构建查询来查找不及格的学生
      let query = supabase
        .from('grade_data')
        .select(`
          student_id,
          name,
          class_name,
          exam_title,
          total_score,
          chinese_score,
          math_score,
          english_score,
          physics_score,
          chemistry_score
        `);

      // 根据科目构建条件
      const conditions: string[] = [];
      for (const subject of subjects) {
        if (subject === 'total') {
          conditions.push(`total_score.lt.${threshold}`);
        } else {
          conditions.push(`${subject}_score.lt.${threshold}`);
        }
      }

      if (conditions.length > 0) {
        query = query.or(conditions.join(','));
      }

      const { data: gradeData, error } = await query.limit(1000);

      if (error) {
        throw new Error(`查询成绩数据失败: ${error.message}`);
      }

      // 处理查询结果
      for (const record of gradeData || []) {
        // 检查是否已存在相同的预警
        const existingWarning = await this.checkExistingWarning(
          record.student_id,
          rule.id,
          { exam_title: record.exam_title }
        );

        if (existingWarning) {
          continue; // 跳过已存在的预警
        }

        matches.push({
          studentId: record.student_id,
          studentData: {
            name: record.name,
            class_name: record.class_name,
            exam_title: record.exam_title,
            scores: {
              total: record.total_score,
              chinese: record.chinese_score,
              math: record.math_score,
              english: record.english_score,
              physics: record.physics_score,
              chemistry: record.chemistry_score
            }
          },
          matchedConditions: {
            rule_type: 'grade_fail',
            threshold,
            subjects,
            failing_subjects: subjects.filter(subject => {
              const scoreField = subject === 'total' ? 'total_score' : `${subject}_score`;
              return (record as any)[scoreField] < threshold;
            })
          },
          severity: rule.severity,
          shouldGenerateWarning: true
        });
      }

      return matches;
    } catch (error) {
      console.error('评估成绩不及格场景失败:', error);
      return matches;
    }
  }

  /**
   * 评估成绩下降场景
   */
  private async evaluateGradeDeclineScenario(rule: WarningRule): Promise<StudentMatch[]> {
    const matches: StudentMatch[] = [];
    const parameters = rule.metadata?.scenario?.parameters || {};
    const declineThreshold = parameters.decline_threshold || 15;
    const consecutiveCount = parameters.consecutive_count || 2;
    const subjects = parameters.subjects || ['total'];

    try {
      // 查询最近的成绩数据，按学生和考试时间排序
      const { data: gradeData, error } = await supabase
        .from('grade_data')
        .select(`
          student_id,
          name,
          class_name,
          exam_title,
          exam_date,
          total_score,
          chinese_score,
          math_score,
          english_score
        `)
        .order('student_id')
        .order('exam_date', { ascending: false });

      if (error) {
        throw new Error(`查询成绩数据失败: ${error.message}`);
      }

      // 按学生分组分析成绩趋势
      const studentGroups = (gradeData || []).reduce((acc, record) => {
        if (!acc[record.student_id]) {
          acc[record.student_id] = [];
        }
        acc[record.student_id].push(record);
        return acc;
      }, {} as Record<string, any[]>);

      for (const [studentId, records] of Object.entries(studentGroups)) {
        if (records.length < consecutiveCount + 1) continue;

        // 检查连续下降
        let consecutiveDeclines = 0;
        let maxDecline = 0;
        
        for (let i = 0; i < records.length - 1; i++) {
          const current = records[i];
          const previous = records[i + 1];

          for (const subject of subjects) {
            const currentScore = subject === 'total' ? current.total_score : current[`${subject}_score`];
            const previousScore = subject === 'total' ? previous.total_score : previous[`${subject}_score`];
            
            if (currentScore && previousScore) {
              const decline = previousScore - currentScore;
              if (decline >= declineThreshold) {
                consecutiveDeclines++;
                maxDecline = Math.max(maxDecline, decline);
                break; // 只要有一科下降就算
              }
            }
          }
          
          if (consecutiveDeclines >= consecutiveCount) {
            // 检查是否已存在相同预警
            const existingWarning = await this.checkExistingWarning(
              studentId,
              rule.id,
              { consecutive_declines: consecutiveDeclines }
            );

            if (!existingWarning) {
              matches.push({
                studentId,
                studentData: {
                  name: current.name,
                  class_name: current.class_name,
                  recent_exams: records.slice(0, consecutiveCount + 1)
                },
                matchedConditions: {
                  rule_type: 'grade_decline',
                  decline_threshold: declineThreshold,
                  consecutive_count: consecutiveCount,
                  actual_consecutive_declines: consecutiveDeclines,
                  max_decline: maxDecline,
                  subjects
                },
                severity: rule.severity,
                shouldGenerateWarning: true
              });
            }
            break;
          }
        }
      }

      return matches;
    } catch (error) {
      console.error('评估成绩下降场景失败:', error);
      return matches;
    }
  }

  /**
   * 评估考试退步场景
   */
  private async evaluateExamRegressionScenario(rule: WarningRule): Promise<StudentMatch[]> {
    const matches: StudentMatch[] = [];
    const parameters = rule.metadata?.scenario?.parameters || {};
    const regressionThreshold = parameters.regression_threshold || 10;
    const subjects = parameters.subjects || ['total'];

    try {
      // 获取最近两次考试的数据
      const { data: recentExams, error: examsError } = await supabase
        .from('grade_data')
        .select('exam_title, exam_date')
        .order('exam_date', { ascending: false })
        .limit(2);

      if (examsError || !recentExams || recentExams.length < 2) {
        return matches;
      }

      const [latestExam, previousExam] = recentExams;

      // 查询这两次考试的成绩数据
      const { data: gradeData, error } = await supabase
        .from('grade_data')
        .select(`
          student_id,
          name,
          class_name,
          exam_title,
          total_score,
          chinese_score,
          math_score,
          english_score
        `)
        .in('exam_title', [latestExam.exam_title, previousExam.exam_title]);

      if (error) {
        throw new Error(`查询考试成绩失败: ${error.message}`);
      }

      // 按学生分组对比成绩
      const studentScores = (gradeData || []).reduce((acc, record) => {
        if (!acc[record.student_id]) {
          acc[record.student_id] = { student_data: record };
        }
        
        if (record.exam_title === latestExam.exam_title) {
          acc[record.student_id].latest = record;
        } else if (record.exam_title === previousExam.exam_title) {
          acc[record.student_id].previous = record;
        }
        
        return acc;
      }, {} as Record<string, any>);

      for (const [studentId, data] of Object.entries(studentScores)) {
        const { latest, previous, student_data } = data;
        
        if (!latest || !previous) continue;

        let hasRegression = false;
        let maxRegression = 0;
        const regressionDetails: Record<string, number> = {};

        for (const subject of subjects) {
          const latestScore = subject === 'total' ? latest.total_score : latest[`${subject}_score`];
          const previousScore = subject === 'total' ? previous.total_score : previous[`${subject}_score`];
          
          if (latestScore && previousScore) {
            const regression = previousScore - latestScore;
            if (regression >= regressionThreshold) {
              hasRegression = true;
              maxRegression = Math.max(maxRegression, regression);
              regressionDetails[subject] = regression;
            }
          }
        }

        if (hasRegression) {
          // 检查是否已存在相同预警
          const existingWarning = await this.checkExistingWarning(
            studentId,
            rule.id,
            { exam_comparison: `${previousExam.exam_title}_vs_${latestExam.exam_title}` }
          );

          if (!existingWarning) {
            matches.push({
              studentId,
              studentData: {
                name: student_data.name,
                class_name: student_data.class_name,
                latest_exam: latestExam.exam_title,
                previous_exam: previousExam.exam_title,
                latest_scores: {
                  total: latest.total_score,
                  chinese: latest.chinese_score,
                  math: latest.math_score,
                  english: latest.english_score
                },
                previous_scores: {
                  total: previous.total_score,
                  chinese: previous.chinese_score,
                  math: previous.math_score,
                  english: previous.english_score
                }
              },
              matchedConditions: {
                rule_type: 'exam_regression',
                regression_threshold: regressionThreshold,
                max_regression: maxRegression,
                regression_details: regressionDetails,
                subjects
              },
              severity: rule.severity,
              shouldGenerateWarning: true
            });
          }
        }
      }

      return matches;
    } catch (error) {
      console.error('评估考试退步场景失败:', error);
      return matches;
    }
  }

  /**
   * 评估作业拖欠场景
   */
  private async evaluateHomeworkDefaultScenario(rule: WarningRule): Promise<StudentMatch[]> {
    const matches: StudentMatch[] = [];
    const parameters = rule.metadata?.scenario?.parameters || {};
    const defaultCount = parameters.count || 3;
    const includeLate = parameters.include_late || false;

    try {
      // 查询作业提交情况
      let query = supabase
        .from('homework_submissions')
        .select(`
          student_id,
          homework_id,
          submitted_at,
          status,
          homework(title, due_date),
          students(name, class_name)
        `)
        .order('student_id')
        .order('submitted_at', { ascending: false });

      // 根据是否包含迟交来设置状态筛选
      if (includeLate) {
        query = query.in('status', ['missing', 'late']);
      } else {
        query = query.eq('status', 'missing');
      }

      const { data: submissions, error } = await query;

      if (error) {
        throw new Error(`查询作业提交记录失败: ${error.message}`);
      }

      // 按学生分组统计拖欠情况
      const studentDefaults = (submissions || []).reduce((acc, submission) => {
        if (!acc[submission.student_id]) {
          acc[submission.student_id] = {
            student_data: submission.students,
            defaults: []
          };
        }
        acc[submission.student_id].defaults.push(submission);
        return acc;
      }, {} as Record<string, any>);

      for (const [studentId, data] of Object.entries(studentDefaults)) {
        const { student_data, defaults } = data;
        
        if (defaults.length >= defaultCount) {
          // 检查是否已存在相同预警
          const existingWarning = await this.checkExistingWarning(
            studentId,
            rule.id,
            { default_count: defaults.length }
          );

          if (!existingWarning) {
            matches.push({
              studentId,
              studentData: {
                name: student_data?.name || '未知学生',
                class_name: student_data?.class_name || '未知班级',
                default_homeworks: defaults.map((d: any) => ({
                  title: d.homework?.title,
                  due_date: d.homework?.due_date,
                  status: d.status
                }))
              },
              matchedConditions: {
                rule_type: 'homework_default',
                default_count: defaults.length,
                required_count: defaultCount,
                include_late: includeLate
              },
              severity: rule.severity,
              shouldGenerateWarning: true
            });
          }
        }
      }

      return matches;
    } catch (error) {
      console.error('评估作业拖欠场景失败:', error);
      return matches;
    }
  }

  /**
   * 评估连续失败场景
   */
  private async evaluateConsecutiveFailScenario(rule: WarningRule): Promise<StudentMatch[]> {
    const matches: StudentMatch[] = [];
    const parameters = rule.metadata?.scenario?.parameters || {};
    const failCount = parameters.fail_count || 3;
    const threshold = parameters.threshold || 60;
    const subjects = parameters.subjects || ['total'];

    try {
      // 查询最近的成绩数据，按考试时间倒序
      const { data: gradeData, error } = await supabase
        .from('grade_data')
        .select(`
          student_id,
          name,
          class_name,
          exam_title,
          exam_date,
          total_score,
          chinese_score,
          math_score,
          english_score
        `)
        .order('student_id')
        .order('exam_date', { ascending: false });

      if (error) {
        throw new Error(`查询成绩数据失败: ${error.message}`);
      }

      // 按学生分组分析连续失败
      const studentGroups = (gradeData || []).reduce((acc, record) => {
        if (!acc[record.student_id]) {
          acc[record.student_id] = [];
        }
        acc[record.student_id].push(record);
        return acc;
      }, {} as Record<string, any[]>);

      for (const [studentId, records] of Object.entries(studentGroups)) {
        if (records.length < failCount) continue;

        let consecutiveFails = 0;
        const failedExams: any[] = [];

        for (const record of records) {
          let hasFail = false;

          for (const subject of subjects) {
            const score = subject === 'total' ? record.total_score : record[`${subject}_score`];
            if (score && score < threshold) {
              hasFail = true;
              break;
            }
          }

          if (hasFail) {
            consecutiveFails++;
            failedExams.push(record);
            
            if (consecutiveFails >= failCount) {
              // 检查是否已存在相同预警
              const existingWarning = await this.checkExistingWarning(
                studentId,
                rule.id,
                { consecutive_fails: consecutiveFails }
              );

              if (!existingWarning) {
                matches.push({
                  studentId,
                  studentData: {
                    name: record.name,
                    class_name: record.class_name,
                    failed_exams: failedExams.slice(0, failCount)
                  },
                  matchedConditions: {
                    rule_type: 'consecutive_fail',
                    fail_count: consecutiveFails,
                    required_count: failCount,
                    threshold,
                    subjects
                  },
                  severity: rule.severity,
                  shouldGenerateWarning: true
                });
              }
              break;
            }
          } else {
            // 中断连续失败
            break;
          }
        }
      }

      return matches;
    } catch (error) {
      console.error('评估连续失败场景失败:', error);
      return matches;
    }
  }

  /**
   * 评估班级预警场景
   */
  private async evaluateClassWarningScenario(rule: WarningRule): Promise<StudentMatch[]> {
    const matches: StudentMatch[] = [];
    const parameters = rule.metadata?.scenario?.parameters || {};
    const passRateThreshold = parameters.pass_rate_threshold || 0.6;
    const threshold = parameters.score_threshold || 60;

    try {
      // 查询最近考试的班级成绩统计
      const { data: gradeData, error } = await supabase
        .from('grade_data')
        .select(`
          class_name,
          exam_title,
          total_score,
          student_id,
          name
        `)
        .order('exam_date', { ascending: false });

      if (error) {
        throw new Error(`查询成绩数据失败: ${error.message}`);
      }

      // 按班级和考试分组统计及格率
      const classStats = (gradeData || []).reduce((acc, record) => {
        const key = `${record.class_name}_${record.exam_title}`;
        if (!acc[key]) {
          acc[key] = {
            class_name: record.class_name,
            exam_title: record.exam_title,
            total_students: 0,
            passed_students: 0,
            students: []
          };
        }
        
        acc[key].total_students++;
        acc[key].students.push({
          student_id: record.student_id,
          name: record.name,
          score: record.total_score
        });
        
        if (record.total_score && record.total_score >= threshold) {
          acc[key].passed_students++;
        }
        
        return acc;
      }, {} as Record<string, any>);

      // 检查每个班级的及格率
      for (const [key, stats] of Object.entries(classStats)) {
        const passRate = stats.total_students > 0 ? stats.passed_students / stats.total_students : 0;
        
        if (passRate < passRateThreshold) {
          // 为班级中的每个学生生成预警（如果他们不及格）
          const failedStudents = stats.students.filter((s: any) => !s.score || s.score < threshold);
          
          for (const student of failedStudents) {
            // 检查是否已存在相同预警
            const existingWarning = await this.checkExistingWarning(
              student.student_id,
              rule.id,
              { class_pass_rate_context: key }
            );

            if (!existingWarning) {
              matches.push({
                studentId: student.student_id,
                studentData: {
                  name: student.name,
                  class_name: stats.class_name,
                  exam_title: stats.exam_title,
                  personal_score: student.score,
                  class_pass_rate: Math.round(passRate * 100),
                  class_total_students: stats.total_students,
                  class_passed_students: stats.passed_students
                },
                matchedConditions: {
                  rule_type: 'class_warning',
                  class_pass_rate: passRate,
                  pass_rate_threshold: passRateThreshold,
                  score_threshold: threshold
                },
                severity: rule.severity,
                shouldGenerateWarning: true
              });
            }
          }
        }
      }

      return matches;
    } catch (error) {
      console.error('评估班级预警场景失败:', error);
      return matches;
    }
  }

  /**
   * 评估传统规则（非场景化）
   */
  private async evaluateTraditionalRule(rule: WarningRule): Promise<StudentMatch[]> {
    // TODO: 实现传统规则评估逻辑
    return [];
  }

  /**
   * 检查是否已存在相同的预警记录
   */
  private async checkExistingWarning(
    studentId: string,
    ruleId: string,
    context: Record<string, any> = {}
  ): Promise<boolean> {
    try {
      const { data, error } = await supabase
        .from('warning_records')
        .select('id')
        .eq('student_id', studentId)
        .eq('rule_id', ruleId)
        .eq('status', 'active')
        .limit(1);

      if (error) {
        console.error('检查已存在预警失败:', error);
        return false;
      }

      return (data || []).length > 0;
    } catch (error) {
      console.error('检查已存在预警失败:', error);
      return false;
    }
  }

  /**
   * 创建预警记录
   */
  private async createWarningRecord(
    rule: WarningRule,
    match: StudentMatch
  ): Promise<string | null> {
    try {
      const warningData = {
        student_id: match.studentId,
        rule_id: rule.id,
        details: {
          student_data: match.studentData,
          matched_conditions: match.matchedConditions,
          generated_by: 'warning_engine',
          generated_at: new Date().toISOString()
        },
        status: 'active' as const
      };

      const { data, error } = await supabase
        .from('warning_records')
        .insert(warningData)
        .select('id')
        .single();

      if (error) {
        console.error('创建预警记录失败:', error);
        return null;
      }

      return data.id;
    } catch (error) {
      console.error('创建预警记录失败:', error);
      return null;
    }
  }

  /**
   * 获取引擎运行状态
   */
  isEngineRunning(): boolean {
    return this.isRunning;
  }

  /**
   * 获取当前执行ID
   */
  getCurrentExecutionId(): string | null {
    return this.executionId;
  }
}

// 导出单例引擎实例
export const warningEngine = new WarningEngine();

// 便捷的执行函数
export async function executeWarningRules(
  executionType: ExecutionType = 'manual',
  triggerEvent?: string
): Promise<EngineExecutionResult> {
  return warningEngine.executeAllRules(executionType, triggerEvent);
}

// 检查引擎状态
export function getEngineStatus(): {
  isRunning: boolean;
  executionId: string | null;
} {
  return {
    isRunning: warningEngine.isEngineRunning(),
    executionId: warningEngine.getCurrentExecutionId()
  };
}

// 导出类型
export type { EngineExecutionResult, RuleExecutionResult, ExecutionType };